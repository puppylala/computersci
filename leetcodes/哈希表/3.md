### 好做法
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        count = 0
        st = set(nums)
        for x in st:
            if x-1 in st:
                continue
            y = x+1
            while y in st:
                y += 1
            count = max(count, y - x)
        return count
```
### 我的两种想法
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        #像动态规划
        if nums==[]:
            return 0
        nums=set(nums)
        dict1={}
        max1=0
        sum1=0
        for i in nums:
            dict1[i]=[1]
        for k in nums:
            if k+1 in nums:
                dict1[k][0]+=dict1[k+1][0]
                dict1[k+1]=dict1[k]
        a=max(dict1.values())
        return a[0]
```
```python
class Solution:
    def longestConsecutive(self, nums: List[int]) -> int:
        if not nums:
            return 0
        
        nums_set = set(nums)
        
        class UnionFind:
            def __init__(self):
                self.parent = {}
                self.size = {}
            
            def add(self, x):
                if x not in self.parent:
                    self.parent[x] = x
                    self.size[x] = 1
            
            def find(self, x):
                if self.parent[x] != x:
                    self.parent[x] = self.find(self.parent[x])
                return self.parent[x]
            
            def union(self, x, y):
                root_x = self.find(x)
                root_y = self.find(y)
                if root_x != root_y:
                    # 按大小合并
                    if self.size[root_x] < self.size[root_y]:
                        self.parent[root_x] = root_y
                        self.size[root_y] += self.size[root_x]
                    else:
                        self.parent[root_y] = root_x
                        self.size[root_x] += self.size[root_y]
        
        uf = UnionFind()
        
        # 第一步：添加所有数字
        for num in nums_set:
            uf.add(num)
        
        # 第二步：合并连续数字
        for num in nums_set:
            if num + 1 in nums_set:
                uf.union(num, num + 1)
            # 注意：也可以合并num-1，但一个方向就够了
        
        # 第三步：找到最大集合
        return max(uf.size.values()) if uf.size else 0
```
题目：给定一个未排序的整数数组 nums ，找出数字连续的最长序列（不要求序列元素在原数组中连续）的长度。

请你设计并实现时间复杂度为 O(n) 的算法解决此问题。

示例 1：

输入：nums = [100,4,200,1,3,2]
输出：4
解释：最长数字连续序列是 [1, 2, 3, 4]。它的长度为 4。
# 思考
题目中要求时间复杂度是O(n),对列表进行排序就已经nlogn了，因此要在不排序的情况下找。最好的方式就是dfs，保证从最大值或者最小值开始查找，可以在中途值跳过，但我怎么也想不到。我最开始想用链式引用，比如我想要list1=list2，
然后list2=list3，但此时list1仍在引用list2。内存上是这样：list1=list2的时候假如list2是[1]，实际上是令list1与list2都指向了[1]所占的内存地址，然后list2=list3时将list2与list3都指向了list3=[2]所占的内存地址。
要做到真正的链式引用很难，所以我后来使用了并查集来实现这一目的，也是成功以O(n)完成，但是过于麻烦了。
